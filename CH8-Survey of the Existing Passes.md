- Let us get started with how you even begin this journey of finding what the middle end has to offer.
- using the description of this pass, you can find where it is implemented by running from your LLVM source directory something such as the following:
  ```
  git grep "the short description of the pass" llvm
  ```
- At this point, you need to use a second command to check which passes are indeed supported by the new pass manager. This command prints the names of all the passes that the new pass manager supports. For instance
  ```
  opt --print-passes
  Module passes:
    always-inline
    annotation2metadata
    attributor
    attributor-light
    called-value-propagation
    canonicalize-aliases
    check-debugify
    constmerge
    coro-cleanup
    coro-early
    cross-dso-cfi
    deadargelim
    debugify
    dfsan
    dot-callgraph
    dxil-upgrade
    elim-avail-extern
    extract-blocks
    forceattrs
    function-import
    globalopt
    globalsplit
    hipstdpar-interpose-alloc
    hipstdpar-select-accelerator-code
    hotcoldsplit
    inferattrs
    inliner-ml-advisor-release
    inliner-wrapper
    inliner-wrapper-no-mandatory-first
    insert-gcov-profiling
    instrorderfile
    instrprof
    internalize
    invalidate<all>
    iroutliner
    jmc-instrumenter
    lower-emutls
    lower-global-dtors
    lower-ifunc
    lowertypetests
    memprof-context-disambiguation
    memprof-module
    mergefunc
    metarenamer
    module-inline
    name-anon-globals
    no-op-module
    objc-arc-apelim
    openmp-opt
    openmp-opt-postlink
    partial-inliner
    pgo-icall-prom
    pgo-instr-gen
    pgo-instr-use
    poison-checking
    print
    print-callgraph
    print-callgraph-sccs
    print-ir-similarity
    print-lcg
    print-lcg-dot
    print-must-be-executed-contexts
    print-profile-summary
    print-stack-safety
    print<inline-advisor>
    print<module-debuginfo>
    pseudo-probe
    pseudo-probe-update
    recompute-globalsaa
    rel-lookup-table-converter
    rewrite-statepoints-for-gc
    rewrite-symbols
    rpo-function-attrs
    sample-profile
    sancov-module
    sanmd-module
    scc-oz-module-inliner
    shadow-stack-gc-lowering
    strip
    strip-dead-debug-info
    strip-dead-prototypes
    strip-debug-declare
    strip-nondebug
    strip-nonlinetable-debuginfo
    synthetic-counts-propagation
    trigger-crash
    trigger-verifier-error
    tsan-module
    verify
    view-callgraph
    wholeprogramdevirt
  Module passes with params:
    asan<kernel>
    cg-profile<in-lto-post-link>
    global-merge<group-by-use;ignore-single-use;max-offset=N;merge-const;merge-external;no-group-by-use;no-ignore-single-use;no-merge-const;no-merge-external;size-only>
    embed-bitcode<thinlto;emit-summary>
    globaldce<in-lto-post-link>
    hwasan<kernel;recover>
    ipsccp<no-func-spec;func-spec>
    loop-extract<single>
    memprof-use<profile-filename=S>
    msan<recover;kernel;eager-checks;track-origins=N>
    print<structural-hash><detailed>
  Module analyses:
    callgraph
    collector-metadata
    inline-advisor
    ir-similarity
    lcg
    module-summary
    no-op-module
    pass-instrumentation
    profile-summary
    stack-safety
    verify
    globals-aa
  Module alias analyses:
    globals-aa
  CGSCC passes:
    argpromotion
    attributor-cgscc
    attributor-light-cgscc
    invalidate<all>
    no-op-cgscc
    openmp-opt-cgscc
  CGSCC passes with params:
    coro-split<reuse-storage>
    function-attrs<skip-non-recursive-function-attrs>
    inline<only-mandatory>
  CGSCC analyses:
    no-op-cgscc
    fam-proxy
    pass-instrumentation
  Function passes:
    aa-eval
    adce
    add-discriminators
    aggressive-instcombine
    alignment-from-assumptions
    annotation-remarks
    assume-builder
    assume-simplify
    bdce
    bounds-checking
    break-crit-edges
    callbrprepare
    callsite-splitting
    chr
    codegenprepare
    consthoist
    constraint-elimination
    coro-elide
    correlated-propagation
    count-visits
    dce
    declare-to-assign
    dfa-jump-threading
    div-rem-pairs
    dot-cfg
    dot-cfg-only
    dot-dom
    dot-dom-only
    dot-post-dom
    dot-post-dom-only
    dse
    dwarf-eh-prepare
    expand-large-div-rem
    expand-large-fp-convert
    expand-memcmp
    fix-irreducible
    flattencfg
    float2int
    gc-lowering
    guard-widening
    gvn-hoist
    gvn-sink
    helloworld
    indirectbr-expand
    infer-address-spaces
    infer-alignment
    inject-tli-mappings
    instcount
    instnamer
    instsimplify
    interleaved-access
    interleaved-load-combine
    invalidate<all>
    irce
    jump-threading
    kcfi
    lcssa
    libcalls-shrinkwrap
    lint
    load-store-vectorizer
    loop-data-prefetch
    loop-distribute
    loop-fusion
    loop-load-elim
    loop-simplify
    loop-sink
    loop-versioning
    lower-constant-intrinsics
    lower-expect
    lower-guard-intrinsic
    lower-widenable-condition
    loweratomic
    lowerinvoke
    lowerswitch
    make-guards-explicit
    mem2reg
    memcpyopt
    memprof
    mergeicmps
    mergereturn
    move-auto-init
    nary-reassociate
    newgvn
    no-op-function
    objc-arc
    objc-arc-contract
    objc-arc-expand
    pa-eval
    partially-inline-libcalls
    pgo-memop-opt
    place-safepoints
    print
    print-alias-sets
    print-cfg-sccs
    print-memderefs
    print-mustexecute
    print-predicateinfo
    print<access-info>
    print<assumptions>
    print<block-freq>
    print<branch-prob>
    print<cost-model>
    print<cycles>
    print<da>
    print<debug-ata>
    print<delinearization>
    print<demanded-bits>
    print<domfrontier>
    print<domtree>
    print<func-properties>
    print<inline-cost>
    print<inliner-size-estimator>
    print<lazy-value-info>
    print<loops>
    print<memoryssa-walker>
    print<phi-values>
    print<postdomtree>
    print<regions>
    print<scalar-evolution>
    print<stack-safety-local>
    print<uniformity>
    reassociate
    redundant-dbg-inst-elim
    reg2mem
    safe-stack
    scalarize-masked-mem-intrin
    scalarizer
    sccp
    select-optimize
    separate-const-offset-from-gep
    sink
    sjlj-eh-prepare
    slp-vectorizer
    slsr
    stack-protector
    strip-gc-relocates
    structurizecfg
    tailcallelim
    tlshoist
    transform-warning
    trigger-verifier-error
    tsan
    typepromotion
    unify-loop-exits
    vector-combine
    verify
    verify<domtree>
    verify<loops>
    verify<memoryssa>
    verify<regions>
    verify<safepoint-ir>
    verify<scalar-evolution>
    view-cfg
    view-cfg-only
    view-dom
    view-dom-only
    view-post-dom
    view-post-dom-only
    wasm-eh-prepare
  Function passes with params:
    cfguard<check;dispatch>
    early-cse<memssa>
    ee-instrument<post-inline>
    function-simplification<O1;O2;O3;Os;Oz>
    gvn<no-pre;pre;no-load-pre;load-pre;no-split-backedge-load-pre;split-backedge-load-pre;no-memdep;memdep>
    hardware-loops<force-hardware-loops;force-hardware-loop-phi;force-nested-hardware-loop;force-hardware-loop-guard;hardware-loop-decrement=N;hardware-loop-counter-bitwidth=N>
    instcombine<no-use-loop-info;use-loop-info;no-verify-fixpoint;verify-fixpoint;max-iterations=N>
    loop-unroll<O0;O1;O2;O3;full-unroll-max=N;no-partial;partial;no-peeling;peeling;no-profile-peeling;profile-peeling;no-runtime;runtime;no-upperbound;upperbound>
    loop-vectorize<no-interleave-forced-only;interleave-forced-only;no-vectorize-forced-only;vectorize-forced-only>
    lower-matrix-intrinsics<minimal>
    mldst-motion<no-split-footer-bb;split-footer-bb>
    print<da><normalized-results>
    print<memoryssa><no-ensure-optimized-uses>
    print<stack-lifetime><may;must>
    separate-const-offset-from-gep<lower-gep>
    simplifycfg<no-forward-switch-cond;forward-switch-cond;no-switch-range-to-icmp;switch-range-to-icmp;no-switch-to-lookup;switch-to-lookup;no-keep-loops;keep-loops;no-hoist-common-insts;hoist-common-insts;no-sink-common-insts;sink-common-insts;bonus-inst-threshold=N>
    speculative-execution<only-if-divergent-target>
    sroa<preserve-cfg;modify-cfg>
    win-eh-prepare<demote-catchswitch-only>
  Function analyses:
    aa
    access-info
    assumptions
    bb-sections-profile-reader
    block-freq
    branch-prob
    cycles
    da
    debug-ata
    demanded-bits
    domfrontier
    domtree
    func-properties
    gc-function
    inliner-size-estimator
    lazy-value-info
    loops
    memdep
    memoryssa
    no-op-function
    opt-remark-emit
    pass-instrumentation
    phi-values
    postdomtree
    regions
    scalar-evolution
    should-not-run-function-passes
    should-run-extra-vector-passes
    ssp-layout
    stack-safety-local
    targetir
    targetlibinfo
    uniformity
    verify
    basic-aa
    objc-arc-aa
    scev-aa
    scoped-noalias-aa
    tbaa
  Function alias analyses:
    basic-aa
    objc-arc-aa
    scev-aa
    scoped-noalias-aa
    tbaa
  LoopNest passes:
    loop-flatten
    loop-interchange
    loop-unroll-and-jam
    no-op-loopnest
  Loop passes:
    canon-freeze
    dot-ddg
    guard-widening
    indvars
    invalidate<all>
    loop-bound-split
    loop-deletion
    loop-idiom
    loop-instsimplify
    loop-predication
    loop-reduce
    loop-reroll
    loop-simplifycfg
    loop-unroll-full
    loop-versioning-licm
    no-op-loop
    print
    print<ddg>
    print<iv-users>
    print<loop-cache-cost>
    print<loopnest>
  Loop passes with params:
    licm<allowspeculation>
    lnicm<allowspeculation>
    loop-rotate<no-header-duplication;header-duplication;no-prepare-for-lto;prepare-for-lto>
    simple-loop-unswitch<nontrivial;no-nontrivial;trivial;no-trivial>
  Loop analyses:
    ddg
    iv-users
    no-op-loop
    pass-instrumentation
  Machine module passes (WIP):
  Machine function passes (WIP):
  Machine function analyses (WIP):
    pass-instrumentation
  ```

- The developer tool named opt acts as a driver for all the LLVM-IR-to-LLVM-IR passes. As such, it covers everything that exists in the middle end. Therefore, to get an overview of everything that is available there, you can simply leverage the help message offered by this tool. But there is a caveat. This tool allows you to use both the legacy pass manager and the new one. Therefore, the default help message (available through the --help option) covers both managers indiscriminately. In other words, what is printed may go beyond the middle end since the legacy pass manager also drives the backends
- Therefore, the default help message (available through the --help option) covers both managers indiscriminately. This command describes how to use the opt tool and lists all the passes you can run, but it does not tell you which one runs with each pass manager

- These subdirectories, as identified by the name after each bullet point, contain, respectively:
  - AggressiveInstCombine: A more aggressive version of instcombiner; see the InstCombine point that follows.
  - Coroutines: Transformations around the lowering of coroutines. A coroutine is a function that can be resumed or suspended without locking the current thread. The lowering is usually highly specific to a source language.
  - HipStdPar: Transformations to enable the HIP C++ standard parallelism support.
  - IPO: Interprocedural optimizations, or IPOs, are transformations that apply across procedures, for instance, inlining, which takes the IR of the callee function and puts it in the IR of its caller.
  - InstCombine: Transformations that apply simple rewrite patterns that are beneficial for all targets. Instrumentation: Transformations used for instrumentation purposes. These transformations add constructs to the IR to maintain specific data structures next to the original IR. These are used to collect information for performance purposes, such as program-guided optimization (PGO), or for debugging purposes, like what a sanitizer would need to diagnost use-after-free issues or undefined behaviors.
  - Scalar: Transformations that are non-vector-related. This includes many different optimizations, of which the loop optimizations are unrelated to vectorization (see the Vectorize bullet point below).
  - Utils: Generally useful passes or helper functions used to transform the LLVM IR.
  - Vectorize: Transformations that produce vectorized code, meaning code that follows a singleinstruction multiple-data (SIMD) model. In other words, passes contained in this directory produce LLVM IR instructions that use vector types.


- Using the list of files returned by this command, you can invoke lit to re-run a specific test or subset of the tests and see the pass in action by looking at the input IR and the output IR
  ```
  git grep -l 'RUN: .*always-inline' llvm/test
  ```

